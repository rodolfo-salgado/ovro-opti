"""
Sky optimizer

Given a list of regions with coordinates, delta_t_obs, and observability
ranges, returns a sorted list in such a way that all the regions are
observed taking a minimum time.

to do
-----
    - Add 3C286 for daily observations
        - Extend this to any other sources that need faster cadence

    - Improve optimization by changing the order in which observable sources
    are observed to reduce slewing time

    - Fill gaps in the observations automatically

Walter Max-Moerbeck, March 4, 2009.
"""
import pickle
import numpy
import random
import pylab
import math
import time
import copy
import telescope_data as tel_data
import coord_utils as cu
import ipynb.fs.full.region_optimizer as ro
import ipynb.fs.full.py40m_astro as pastro


def load_variables(savefile):
    """ Loads the sources and regions variables previously generated by
    region_optmizer.py
    """
    file = open(savefile)
    sources = pickle.load(file)
    regions = pickle.load(file)
    file.close()
    return sources, regions

def save_results(regions_sorted, regions_sorted_lst, savefile):
    """ Save the variables for use by the write schedule module

    regions_sorted:    Sorted list with the region numbers
    regions_sorted_lst: Sorted list with lsts of observation
    """
    file = open(savefile, 'w')
    pickle.dump(regions_sorted, file)
    pickle.dump(regions_sorted_lst, file)
    file.close()
    return

def get_region_by_number(regions, number):
    """ Return the region with the given Healpix number

    This number will not change as new sources are added to the schedule which
    makes it convenient to index them.

    Note: since the region splitting, number is actually a string, because
    splitted regions get a string ID, e.g. '105a', '105b'.
    """
    # default value
    region = None
    # loop through the regions until finding it
    for reg in regions:
        if str(reg['number']) == str(number):
            region = reg
    return region

def position_last_source_on_region(region, sources, lst):
    """ Get the ZA/AZ for the last source on a region at a given lst

    Returns za, az in degrees
    """
    # get name for last source in region
    last_source = region['sources'][region['order'][-1]]
    # get ra/dec for the source
    ra, dec = sources[last_source]['ra'], sources[last_source]['dec']
    # calculate za/az coordinates for lst
    za, az = cu.radec_zaaz(ra, dec, lst)
    return za, az


#------------------------------------------------------------------------------
def initialize_regions_order(regions):
    """ Initialize the regions_order list
    """
    regions_order = [region['number'] for region in regions]
    return regions_order


#-------------------------------------------------------------------------------
def sort_regions_by_ra(regions, regions_list):
    """ Sort regions by RA.
    Returns a region_order vector. Only consider regions in region_list

    regions_list:   List of the number for the regions we want to include
    """
    # Get a list with ra for those regions
    ra = numpy.array([get_region_by_number(regions, i)['ra'] \
                           for i in regions_list])
    # Sort the array
    regions_sorted = list(numpy.array(regions_list)[ra.argsort()])
    return regions_sorted


#------------------------------------------------------------------------------
def sort_regions_by_dec(regions, regions_list):
    """ Sort regions by DEC.
    Returns a region_order vector. Only consider regions in region_list

    regions_list:   List of the number for the regions we want to include
    """
    # Get a list with dec for those regions
    dec = numpy.array([get_region_by_number(regions, i)['dec'] \
                           for i in regions_list])
    # Sort the array
    regions_sorted = list(numpy.array(regions_list)[dec.argsort()])
    return regions_sorted

def sort_regions_by_lst(regions_order, regions_order_lst, lst_start):
    """ Sort regions by LST. Pop out the region that's there both at the beginning
    the end of the list (new sorting routine which allows any start LST time)
    Returns a region_order and lst vector.
    regions_order: original order of the regions
    regions_order_lst: original lst order of the regions

    NOTES:
    - Assumes that the wanted LST range is between 0 and 72h
    - The final LST list will not be optimized yet because it includes
    2 of the same regions and the other one is just popped out.
    Therefore need to simulate the order to get the final LST list.

    2012-04-20 / thovatta

    """
#    print "regions before sorting:", regions_order
    subtracted_lst=[]
    for lst in regions_order_lst:
        #account for schedules where initial lst start > wanted lst start
        if regions_order_lst[0] > (lst_start+0.5):
            lst -= 24
#        print 'lst before sorting', lst
        if lst < lst_start:
            lst += int(regions_order_lst[-1]/24)*24+24
#        print 'lst after sorting', lst
        subtracted_lst.append(lst)
    # Sort the array
    regions_sorted = list(numpy.array(regions_order)[numpy.array(subtracted_lst).argsort()])
    # sorted_lst = list(numpy.array(subtracted_lst)[numpy.array(subtracted_lst).argsort()])
    # print "regions after sorting:", regions_sorted, "at lst", sorted_lst
    return regions_sorted