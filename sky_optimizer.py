"""
Sky optimizer
Given a list of regions with coordinates, delta_t_obs, and observability
ranges, returns a sorted list in such a way that all the regions are
observed taking a minimum time.
to do
-----
    - Add 3C286 for daily observations
        - Extend this to any other sources that need faster cadence
    - Improve optimization by changing the order in which observable sources
    are observed to reduce slewing time
    - Fill gaps in the observations automatically
Walter Max-Moerbeck, March 4, 2009.
"""
import pickle
import numpy
import random
import pylab
import math
import time
import copy
import telescope_data as tel_data
import coord_utils as cu
import ipynb.fs.full.region_optimizer as ro
import ipynb.fs.full.py40m_astro as pastro

def load_variables(savefile):
    """ Loads the sources and regions variables previously generated by
    region_optmizer.py
    """
    with open(savefile) as file:
        sources = pickle.load(file)
        regions = pickle.load(file)
    return sources, regions

def save_results(regions_sorted, regions_sorted_lst, savefile):
    """ Save the variables for use by the write schedule module
    regions_sorted:    Sorted list with the region numbers
    regions_sorted_lst: Sorted list with lsts of observation
    """
    with open(savefile, 'w') as file:
        pickle.dump(regions_sorted, file)
        pickle.dump(regions_sorted_lst, file)
    return

def order_regions_slew_time(regions,
                                sources,
                                lst_start=0,
                                lst_obs_win=12./60.,
                                za_t=0.0,
                                az_t=180.0,
                                delta_lst=5./60.,
                                daily_regions_list=\
                              [{'number': '136', #3C286 custom observing times
                                'obs_range': [[10.0, 11.7],[15.1,17.2]]},
                               {'number': '137', #DR21
                                'obs_range': [[16.25,18.8],[22.5,24.0]]},
                               {'number': '138', #3C48
                                'obs_range': [[5.3, 6.5],[20.5,22.7]]},
                               {'number': '142', #3C147
                                'obs_range': [[2.0, 4.0],[7.25,9.25]]},
                               {'number': '139', #NGC7027
                                'obs_range': [[16.75,19.3],[22.8,24.0]]},
                               {'number': '140', #3C295
                                'obs_range': [[10.5, 12.75],[15.5,18.75]]},
                               {'number': '141', #3C161
                                'obs_range': [[7.5, 9.25]]}],
                                sun_jd=0):
    """ Order regions minimizing the slew time only and starting at each of the 135 regions
        messy code which orders the sources based on smalles slewing time and returns the mimimun found.
        Daily calibration regions are accounted for in a not-so-clever way.
        This routine also accounts for the sun_angle by eliminating regions
        within 10 degrees from the sun on a give MJD. Returns the mimimun order, minimum time and minimum
        order_lst and the lst_start of the schedules
        2012-04-20 / thovatta
        #Modified to have all polarization calibrators to be observed once per day.
    """
    # First deal with daily regions and add observation counter to daily regions
    for reg in daily_regions_list:
        reg['n_obs'] = 0
        reg['lst'] = -30
    # daily_regions are eliminated from list, they are treated specially
    daily_regions_numbers = [reg['number'] for reg in daily_regions_list]
    regions_sun = [reg for reg in regions if\
                        reg['number'] not in daily_regions_numbers]
    #Check if the region is within 10 degrees from the sun in the middle of the schedule range
    #if a sun_jd is given
    regions_zero_lst = []
    if sun_jd != 0:
        sun_ra, sun_dec = cu.sun_pos(sun_jd)
        print ('sun ra dec=', sun_ra, sun_dec)
        for reg in regions_sun:
            sep=pastro.sky_sep(pastro.ephem.degrees(reg['ra']*numpy.pi/180.0),pastro.ephem.degrees(reg['dec']*numpy.pi/180.0),pastro.ephem.degrees(sun_ra*numpy.pi/180.0), pastro.ephem.degrees(sun_dec*numpy.pi/180.0)) * 180.0 / numpy.pi
            print ('region', reg['number'], 'sun_angle', sep, reg['ra'], reg['dec'])
            if sep > 10:
                regions_zero_lst.append(reg['number'])
    else:
        regions_zero_lst.append(reg['number'] for reg in regions_sun)
    print ('regions after sun angle', regions_zero_lst)
    print ('lst_start =', lst_start)
    initial_start_lst = lst_start #needed for checking if a or b schedules are being generated
    #check which regions are observable at LST 0 in order to select the one which has the best total time from those
    min_total_time = 10000
    min_order = []
    min_order_lst = []
    min_lst_start = 0
    lst_start=0
    while lst_start < 24:
        regions_order = []
        for region_number in regions_zero_lst:
        # get the region corresponding to region_number
            region = get_region_by_number(regions, region_number)
            if region is None:
                continue
            # find if region is observable at this lst and add it and the slew time to lists
            if cu.check_observability(region['obs_range'], lst_start) and\
                        cu.check_observability(region['obs_range'],
                                               lst_start + lst_obs_win + region['obstime']):
                regions_order.append(region['number'])
        #do the same for daily regions and see if they are observable at the start_lst
        for region_number in daily_regions_numbers:
        # get the region corresponding to region_number
            region = get_region_by_number(regions, region_number)
            if region is None:
                continue
            # find if region is observable at this lst and add it and the slew time to lists
            if cu.check_observability(region['obs_range'], lst_start) and\
                        cu.check_observability(region['obs_range'],
                                               lst_start + lst_obs_win + region['obstime']):
                regions_order.append(region['number'])
        print ('regions observable at lst =', lst_start, 'are:', regions_order)
        # by starting at each region, go through other regions selecting always the shortest slew time
        # loop through the regions
        for region_number in regions_order:
            regions_added = []
            regions_added_lst = []
            non_grouped_regions = regions_zero_lst[:]
            added=0 #checking if time for 3C286 full track has been added
             # get the region corresponding to the region_number and define the lst to be the lst when this region becomes observable
            start_region = get_region_by_number(regions, region_number)
             #lst = start_region['obs_range'][0][0]
            lst = lst_start
             # simulate observation to check feasibility
             # region position at begining of observation
            za_r, az_r =\
                  cu.radec_zaaz(start_region['ra'], start_region['dec'], lst)
             # Consider azimuth wrap
            az_r = tel_data.move_in_azimuth(az_t, az_r)
             # slew time from previous telescope position
            t_slew_region = tel_data.slew_time(za_t, az_t, za_r, az_r)
             # observation time
             #t_obs_region = start_region['obstime']
            t_obs_region = calculate_region_obstime(start_region, sources, lst+t_slew_region, az_r)
             #update lst
            lst = lst + t_slew_region
             #lst_start = lst - t_slew_region
             #if region_number == 45:
#            print 'start lst =', lst_start, 'lst=', lst, 'slew = ', t_slew_region, 'range =', start_region['obs_range'], 't_obs = ', t_obs_region
             #the first region must be observable so add into regions_added and take away from regions left
             #check if this is cal region
            if region_number in daily_regions_numbers:
                regions_added.append(start_region['number'])
                regions_added_lst.append(lst)
                for reg in daily_regions_list:
                    if reg['number'] == region_number:
                        reg['n_obs'] += 1
                        reg['lst'] = lst
                lst += t_obs_region
            else:
                #region_pop_index =\
                #    numpy.where(numpy.array(non_grouped_regions) == region_number)[0] # old code before region splitting
                region_pop_index = non_grouped_regions.index(region_number)
                regions_added.append(start_region['number'])
                regions_added_lst.append(lst)
                non_grouped_regions.pop(region_pop_index)
                lst += t_obs_region
            # update telescope position at end of observation
             # this is position for last source at the end
            za_ls, az_ls =\
                    position_last_source_on_region(start_region,
                                                   sources,
                                                   lst)
             # Considering current position of telescope convert geometric to
             # telescope coordinates with azimuth wrap incorporated
            az_ls = tel_data.move_in_azimuth(az_t, az_ls)
            za_t, az_t = za_ls, az_ls
             #go through the remaining regions by adding the smallest slew time one as the next region
            while non_grouped_regions:
#               #Code that was used to see if 3C286 long track can somehow be automatically added. Could not get to work.
#                #check if LST is close to 8:30 LST when 3C286 should be started, only if start_lst != 0
#                print "initial start lst=", initial_start_lst, "added=", added, "lst=",lst
#                if initial_start_lst != 0 and added == 0 and ((lst > 8 and lst < 9) or (lst > 32 and lst < 33)):
#                    print "adding time for 3C286 at lst", lst
#                    lst += 10 #add the amount of time required to observe 3C286
#                    added=1
#                    print "new lst=", lst
                observable_regions = []
                observable_regions_slew = []
                # loop through the regions
                for region_index in non_grouped_regions:
                        # get the region corresponding to region_number
                    region = get_region_by_number(regions, region_index)
                    t_obs_region = calculate_region_obstime(region, sources, lst, az_t)
                        # find if region is observable at this lst and add it and the slew time to lists
                    if cu.check_observability(region['obs_range'], lst) and\
                                cu.check_observability(region['obs_range'],
                                                       lst + lst_obs_win + t_obs_region):
                            # region position at beginning observation
                        za_r, az_r =\
                                    cu.radec_zaaz(region['ra'], region['dec'], lst)
                            # consider Az wrap
                        az_r = tel_data.move_in_azimuth(az_t, az_r)
                            # slew time from previous telescope position
                        t_slew_region = tel_data.slew_time(za_t, az_t, za_r, az_r)
                        observable_regions_slew.append(t_slew_region)
                        observable_regions.append(region_index)
#                print "observable regions at lst", lst, "are", observable_regions
                  # if no region is observable, advance time by a bit and goes to next cycle
                if len(observable_regions) == 0:
                    lst += delta_lst
                    continue
                 # sort regions by slew time and get the region with shortest slew time
                index = numpy.array(observable_regions_slew).argsort()
                observable_regions = list(numpy.array(observable_regions)[index])
                region_index = observable_regions[0]
                region = get_region_by_number(regions, region_index)
                #region_pop_index =\
                #          numpy.where(numpy.array(non_grouped_regions) == region_index)[0] # old code before region splitting
                region_pop_index = non_grouped_regions.index(region_index)
                 # check that region is observable at the end of observation
                za_r, az_r =\
                          cu.radec_zaaz(region['ra'], region['dec'], lst)
                 # Consider azimuth wrap
                az_r = tel_data.move_in_azimuth(az_t, az_r)
               # slew time from previous telescope position
                t_slew_region = tel_data.slew_time(za_t, az_t, za_r, az_r)
                  # observation time
                 #t_obs_region = region['obstime']
                t_obs_region = calculate_region_obstime(region, sources, lst+t_slew_region, az_r)
                if cu.check_observability(region['obs_range'],
                                      lst + t_slew_region + t_obs_region):
                       # observe the source
                    regions_added.append(region['number'])
                    regions_added_lst.append(lst)
                    lst += t_obs_region + t_slew_region
                    non_grouped_regions.pop(region_pop_index)
#                    print "observing region ", region['number']
                       # update telescope position at end of observation
                       # this is position for last source at the end
                    za_ls, az_ls =\
                         position_last_source_on_region(region,
                                                        sources,
                                                        lst)
                        # Considering current position of telescope convert geometric to
                        # telescope coordinates with azimuth wrap incorporated
                    az_ls = tel_data.move_in_azimuth(az_t, az_ls)
                    za_t, az_t = za_ls, az_ls
                        #check if a daily cal observation could be inserted here. Check that no cal region has been observed within the last
                        # 12 hours and that there are less than 4 added calibrators
                    for reg in daily_regions_list:
                        # get region information
                        reg_day = get_region_by_number(regions, reg['number'])
                        # FIX start:
                        if reg_day is None:
                            continue
                        # FIX end
                        if cu.check_observability(reg['obs_range'], lst) and\
                                     cu.check_observability(reg['obs_range'],lst + lst_obs_win + reg_day['obstime']) and\
                                     lst - reg['lst'] > 20 and\
                                     reg['n_obs'] <= lst / 24:
                            region = reg_day
                                  # check that region is observable at the end of observation
                            za_r, az_r =\
                                      cu.radec_zaaz(region['ra'], region['dec'], lst)
                                  # Consider azimuth wrap
                            az_r = tel_data.move_in_azimuth(az_t, az_r)
                                  # slew time from previous telescope position
                            t_slew_region = tel_data.slew_time(za_t, az_t, za_r, az_r)
                                  # observation time
                            t_obs_region = region['obstime']
                                  # check if the region is observable
                            if cu.check_observability(region['obs_range'],
                                                       lst + t_slew_region + t_obs_region):
                                regions_added.append(region['number'])
                                regions_added_lst.append(lst)
                                reg['n_obs'] += 1
                                reg['lst'] = lst
                                lst += t_obs_region + t_slew_region
                                       # update telescope position at end of observation                                                                                                                    # this is position for last source at the end
                                za_ls, az_ls =\
                                     position_last_source_on_region(region,
                                                                    sources,
                                                                    lst)
                                       # Considering current position of telescope convert geometric to                                                                                                     # telescope coordinates with azimuth wrap incorporated
                                az_ls = tel_data.move_in_azimuth(az_t, az_ls)
                                za_t, az_t = za_ls, az_ls
        #                        print "observed calibrator region ", region['number']
        #                        break #break out of the loop not to include two regions in a row
                else:
                    lst += delta_lst
#            region_number=1 #test purposes!
               #Add the first region into the list so that the schedule makes a full circle and lst start can be shifted
##            regions_added.append(region_number)
##            regions_added_lst.append(lst)
            sorted_regions = sort_regions_by_lst(regions_added, regions_added_lst, initial_start_lst)
            report =simulate_regions_final(regions,
                                            sorted_regions,
                                            initial_start_lst,
                                            sources,
                                            wait=True,
                                            za_t=za_t,
                                            az_t=az_t)
            t_total_i = report_total_time(report)
            # obs = report_obs_time(report)
            slew = report_slew_time(report)
            # wait = report_wait_time(report)
            za, az, t_obs, t_slew, t_wait, sorted_regions_lst = report_stats(report,printing=False)
            total_time = lst - lst_start
            print ('starting with region ', region_number, 'at lst', lst_start, 'total time = ',
                   total_time, 'total simulated time =', t_total_i,  'slew time', slew)
              #re-initialize daily regions
            for reg in daily_regions_list:
                  #print 'daily observations region', reg['number'], 'nobs and lst =', reg['n_obs'], reg['lst']
                reg['n_obs'] = 0
                reg['lst'] = -30
             #check if the total time is less than the mimimum time and if so, copy these into the min time lists
            if (t_total_i < min_total_time):
                min_total_time = t_total_i
                min_order = sorted_regions[:]
                min_order_lst = sorted_regions_lst[:]
                min_lst_start = initial_start_lst
        lst_start += 1
    return min_order, min_total_time, min_order_lst, min_lst_start